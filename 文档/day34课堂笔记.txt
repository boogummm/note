day34课堂笔记

1、线程这块还有那些内容呢？列举一下

	1.1、守护线程

		java语言中线程分为两大类：
			一类是：用户线程
			一类是：守护线程（后台线程）
			其中具有代表性的就是：垃圾回收线程（守护线程）。

		守护线程的特点：
			一般守护线程是一个死循环，所有的用户线程只要结束，
			守护线程自动结束。
		
		注意：主线程main方法是一个用户线程。

		守护线程用在什么地方呢？
			每天00:00的时候系统数据自动备份。
			这个需要使用到定时器，并且我们可以将定时器设置为守护线程。
			一直在那里看着，没到00:00的时候就备份一次。所有的用户线程
			如果结束了，守护线程自动退出，没有必要进行数据备份了。

	1.2、定时器
		定时器的作用：
			间隔特定的时间，执行特定的程序。

			每周要进行银行账户的总账操作。
			每天要进行数据的备份操作。

			在实际的开发中，每隔多久执行一段特定的程序，这种需求是很常见的，
			那么在java中其实可以采用多种方式实现：
				
				可以使用sleep方法，睡眠，设置睡眠时间，没到这个时间点醒来，执行
				任务。这种方式是最原始的定时器。（比较low）

				在java的类库中已经写好了一个定时器：java.util.Timer，可以直接拿来用。
				不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持
				定时任务的。

				在实际的开发中，目前使用较多的是Spring框架中提供的SpringTask框架，
				这个框架只要进行简单的配置，就可以完成定时器的任务。


	1.3、实现线程的第三种方式：实现Callable接口。（JDK8新特性。）
		这种方式实现的线程可以获取线程的返回值。
		之前讲解的那两种方式是无法获取线程返回值的，因为run方法返回void。

		思考：
			系统委派一个线程去执行一个任务，该线程执行完任务之后，可能
			会有一个执行结果，我们怎么能拿到这个执行结果呢？
				使用第三种方式：实现Callable接口方式。


	1.4、关于Object类中的wait和notify方法。（生产者和消费者模式！）

		第一：wait和notify方法不是线程对象的方法，是java中任何一个java对象
		都有的方法，因为这两个方式是Object类中自带的。
			wait方法和notify方法不是通过线程对象调用，
			不是这样的：t.wait()，也不是这样的：t.notify()..不对。
		
		第二：wait()方法作用？
			Object o = new Object();
			o.wait();

			表示：
				让正在o对象上活动的线程进入等待状态，无期限等待，
				直到被唤醒为止。
				o.wait();方法的调用，会让“当前线程（正在o对象上
				活动的线程）”进入等待状态。

		第三：notify()方法作用？
			Object o = new Object();
			o.notify();

			表示：
				唤醒正在o对象上等待的线程。
			
			还有一个notifyAll()方法：
				这个方法是唤醒o对象上处于等待的所有线程。


2、反射机制（比较简单，因为只要会查帮助文档，就可以了。）
	
	2.1、反射机制有什么用？
		通过java语言中的反射机制可以操作字节码文件。
		优点类似于黑客。（可以读和修改字节码文件。）
		通过反射机制可以操作代码片段。（class文件。）
	
	2.2、反射机制的相关类在哪个包下？
		java.lang.reflect.*;
	
	2.3、反射机制相关的重要的类有哪些？

		java.lang.Class：代表整个字节码，代表一个类型，代表整个类。

		java.lang.reflect.Method：代表字节码中的方法字节码。代表类中的方法。

		java.lang.reflect.Constructor：代表字节码中的构造方法字节码。代表类中的构造方法

		java.lang.reflect.Field：代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。

		java.lang.Class：
			public class User{
				// Field
				int no;

				// Constructor
				public User(){
				
				}
				public User(int no){
					this.no = no;
				}

				// Method
				public void setNo(int no){
					this.no = no;
				}
				public int getNo(){
					return no;
				}
			}

3、关于JDK中自带的类加载器：（聊一聊，不需要掌握，知道当然最好！）
	3.1、什么是类加载器？
		专门负责加载类的命令/工具。
		ClassLoader
	
	3.2、JDK中自带了3个类加载器
		启动类加载器:rt.jar
		扩展类加载器:ext/*.jar
		应用类加载器:classpath
	
	3.3、假设有这样一段代码：
		String s = "abc";
		
		代码在开始执行之前，会将所需要类全部加载到JVM当中。
		通过类加载器加载，看到以上代码类加载器会找String.class
		文件，找到就加载，那么是怎么进行加载的呢？

			首先通过“启动类加载器”加载。
				注意：启动类加载器专门加载：C:\Program Files\Java\jdk1.8.0_101\jre\lib\rt.jar
				rt.jar中都是JDK最核心的类库。
			
			如果通过“启动类加载器”加载不到的时候，
			会通过"扩展类加载器"加载。
				注意：扩展类加载器专门加载：C:\Program Files\Java\jdk1.8.0_101\jre\lib\ext\*.jar

	
			如果“扩展类加载器”没有加载到，那么
			会通过“应用类加载器”加载。
				注意：应用类加载器专门加载：classpath中的类。
	
	3.4、java中为了保证类加载的安全，使用了双亲委派机制。
		优先从启动类加载器中加载，这个称为“父”
		“父”无法加载到，再从扩展类加载器中加载，
		这个称为“母”。双亲委派。如果都加载不到，
		才会考虑从应用类加载器中加载。直到加载
		到为止。
		
